package Synchronization;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
class ReentrantLockSynchronization extends Thread{
    ReentrantLock reentrantLock = new ReentrantLock();
    //conditions for even/odd
    Condition ev = reentrantLock.newCondition();
    Condition odd = reentrantLock.newCondition();

    //counter variable
    int c;

    ReentrantLockSynchronization(int c){
        this.c  = c;
    }
    int MAX = 50;

    public void run(){
        while (c <= MAX){
            //acquire the lock
            reentrantLock.lock();
            try {
                //conditions
                if (c % 2 == 1 &&Thread.currentThread().getName().equals("even") ){
                    ev.await();
                } else if (c % 2 == 0 && Thread.currentThread().getName().equals("odd")) {
                    //wait for odd condition
                    odd.await();
                }
                else{
                    System.out.println(Thread.currentThread().getName() + " Thread " + c);
                    c += 1;
                    if (c % 2 == 0){
                        ev.signal();
                    }
                    else{
                        odd.signal();
                    }
                }
            }
            catch (InterruptedException e){
                e.printStackTrace();
            }
            finally {
                //release the lock
                reentrantLock.unlock();
            }
        }
    }
    public static void main(String[]args){
        ReentrantLockSynchronization obj = new ReentrantLockSynchronization(0);
        Thread even = new Thread(obj, "even");
        Thread odd = new Thread(obj, "odd");
        even.start();
        odd.start();
    }
}
//The even threads utilize an even condition Object to wait using the await() method
//and odd threads use an  odd condition to wait using await() method
//when the shared resource is even, we release the even thread using the signal() method
//because the last printed value is an odd value generated by the odd thread
//When the shared resource(t)  is odd, it releases the odd thread using the signal() method because
//the last printed value is an even value generated by the even thread